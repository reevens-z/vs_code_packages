import fitz  # PyMuPDF
import os
import re

def process_pdf(pdf_path, output_dir):
    """
    从PDF中提取文本、表格和图片
    - 文本：排除表格和图片区域后保存为txt文件
    - 表格：识别表格区域并保存为图片
    - 图片：直接提取保存为png文件
    """
    # 创建输出目录
    os.makedirs(output_dir, exist_ok=True)
    
    # 打开PDF文档
    doc = fitz.open(pdf_path)
    
    # 遍历每一页
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        print(f"Processing page {page_num+1}...")
        
        # 1. 提取图片并保存
        image_list = page.get_images(full=True)
        for img_idx, img in enumerate(image_list):
            xref = img[0]  # 图片xref编号
            base_image = doc.extract_image(xref)
            image_bytes = base_image["image"]
            
            # 保存图片
            img_path = f"{output_dir}/page{page_num+1}_img{img_idx}.png"
            with open(img_path, "wb") as f:
                f.write(image_bytes)
            print(f"Saved image: {img_path}")
        
        # 2. 定位表格区域
        blocks = page.get_text("blocks")  # 获取所有文本块
        tables = []
        for block in blocks:
            x0, y0, x1, y1, text, block_type, block_no = block
            if block_type == 1:  # 图片块
                continue
            if is_table_block(block):  # 自定义表格识别逻辑
                tables.append((x0, y0, x1, y1))
                # 保存表格区域为图片
                table_rect = fitz.Rect(x0, y0, x1, y1)
                table_pix = page.get_pixmap(matrix=fitz.Matrix(2, 2), clip=table_rect)
                table_path = f"{output_dir}/page{page_num+1}_table{len(tables)}.png"
                table_pix.save(table_path)
                print(f"Saved table: {table_path}")
        
        # 3. 提取纯文本（排除表格/图片区域）
        text = page.get_text()
        clean_text = remove_blocks_from_text(text, tables, page)
        text_path = f"{output_dir}/page{page_num+1}.txt"
        with open(text_path, "w", encoding="utf-8") as f:
            f.write(clean_text)
        print(f"Saved text: {text_path}")
    
    doc.close()

def is_table_block(block):
    """通过文本密度判断是否为表格"""
    x0, y0, x1, y1, text, block_type, block_no = block
    words = text.split()
    if len(words) < 3:  # 单元格通常包含多个单词
        return False
    # 计算文本密度（字符数/区域面积）
    area = (x1 - x0) * (y1 - y0)
    if area == 0:
        return False
    char_density = len(text) / area
    return char_density > 0.5  # 阈值可调整

def get_line_y(line, page, line_index):
    """
    获取文本行在页面中的垂直坐标（y值）
    
    参数:
        line: 文本行内容
        page: PDF页面对象
        line_index: 行在文本中的索引位置
    
    返回:
        float: 行的y坐标（页面顶部为0）
    """
    # 通过页面搜索文本行来获取坐标
    text_instances = page.search_for(line)
    if text_instances:
        # 返回第一个匹配的矩形区域的y坐标
        return text_instances[0].y0
    else:
        # 如果没有精确匹配，使用估算方法
        # 假设文本是顺序排列的，每行高度约为12点
        return line_index * 12

def is_line_in_blocks(line_y, blocks, tolerance=5):
    """
    判断行是否在表格/图片块区域内
    
    参数:
        line_y: 行的y坐标
        blocks: 块区域列表，每个块为(x0, y0, x1, y1)
        tolerance: 容差范围，用于处理坐标精度问题
    
    返回:
        bool: 如果行在块内返回True，否则返回False
    """
    for block in blocks:
        x0, y0, x1, y1 = block
        # 检查行的y坐标是否在块的垂直范围内（考虑容差）
        if (y0 - tolerance) <= line_y <= (y1 + tolerance):
            return True
    return False

def remove_blocks_from_text(text, blocks, page):
    """
    根据区域坐标过滤文本，排除表格和图片区域的内容
    
    参数:
        text: 原始文本
        blocks: 需要排除的块区域列表
        page: PDF页面对象（用于获取坐标信息）
    
    返回:
        str: 过滤后的纯文本
    """
    if not blocks:  # 如果没有需要排除的块，直接返回原文本
        return text
    
    lines = text.split('\n')
    filtered_lines = []
    
    for i, line in enumerate(lines):
        if not line.strip():  # 跳过空行
            filtered_lines.append(line)
            continue
            
        line_y = get_line_y(line, page, i)
        
        if not is_line_in_blocks(line_y, blocks):
            filtered_lines.append(line)
    
    return '\n'.join(filtered_lines)

def clean_extracted_text(text):
    """
    清理提取的文本，移除多余的空白字符
    """
    # 移除连续的空行，最多保留一个空行
    text = re.sub(r'\n\s*\n', '\n\n', text)
    # 移除行首行尾的空白字符
    text = '\n'.join(line.strip() for line in text.split('\n'))
    return text

# 测试代码
if __name__ == "__main__":
    # 示例调用 - 请将 "input.pdf" 替换为您的PDF文件路径
    try:
        process_pdf("input.pdf", "output")
        print("PDF解析完成！")
    except Exception as e:
        print(f"处理PDF时出错: {e}")
        print("请确保：")
        print("1. input.pdf 文件存在")
        print("2. 已安装 PyMuPDF: pip install PyMuPDF")
